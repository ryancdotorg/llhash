#include "../../macros.h"

#ifndef HASH_NAME
/* this exists to keep the linter happy */
#define HASH_NAME SHA1

#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <endian.h>
#include "sha1/param.h"
#include "../../util.h"
#include "../../gen/md/sha1/ext.h"
#else
_H include <stdint.h>
_H include <stddef.h>
_H include <string.h>
_H include <endian.h>
_H include STR(../../../src/md/HASH_name/param.h)
_H include STR(../../../util.h)
_H include STR(ext.h)
#endif

#define PBKDF2_NAME JOIN(PBKDF2,HASH_NAME)

void PBKDF2_NAME(
uint8_t dk[], size_t dk_sz,
const uint8_t pass[], size_t pass_sz,
const uint8_t salt[], size_t salt_sz,
uint32_t c) {
  HMAC(CTX) ictx, octx;
  HMAC(Init)(&ictx, pass, pass_sz);
  HMAC(Clone)(&octx, &ictx);
  HMAC(Update)(&octx, salt, salt_sz);

  size_t nout = 0, block = 1;
  uintWS_t T[HASH_STATE_WORDS], U[HASH_STATE_WORDS];

  uint8_t otail[HASH_BLOCK_LENGTH*2], itail[HASH_BLOCK_LENGTH*3];
  memcpy(otail, octx.data, octx.datalen);
  memcpy(itail, ictx.data, ictx.datalen);
  uint8_t otail_blks = HASH(Tail)(otail, (octx.bitlen >> 3) + octx.datalen + 4);
  uint8_t itail_blks = HASH(Tail)(itail, (ictx.bitlen >> 3) + ictx.datalen + HASH_DIGEST_LENGTH);

  while (nout < dk_sz) {
    memcpy(T, octx.state, sizeof(octx.state));
    otail[octx.datalen+0] = (block >> 24) & 0xff;
    otail[octx.datalen+1] = (block >> 16) & 0xff;
    otail[octx.datalen+2] = (block >>  8) & 0xff;
    otail[octx.datalen+3] = (block >>  0) & 0xff;
    HASH(Transform)(T, otail, otail_blks);
    for (size_t i = 1; i < c; ++i) {
      memcpy(U, ictx.state, sizeof(ictx.state));
      HASH(Serialize)(itail + ictx.datalen, T);
      HASH(Transform)(U, itail, itail_blks);
      for (size_t j = 0; j < HASH_STATE_WORDS; ++j) { T[j] ^= U[j]; }
    }

    if (nout + HASH_DIGEST_LENGTH <= dk_sz) {
      HASH(Serialize)(dk + nout, T);
      nout += HASH_DIGEST_LENGTH;
    } else {
      HASH(Partial)(dk + nout, T, dk_sz - nout);
    }
    ++block;
  }

  wipe(&octx, sizeof(octx));
  wipe(&ictx, sizeof(ictx));
  wipe(T);
  wipe(U);
}
